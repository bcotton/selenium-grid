#
# Rakefile managing Selenium Grid components
#
require File.dirname(__FILE__) + '/lib/ruby/tcp_socket_extensions'

desc "Print help"
task :help do
  puts <<-EOS
  
 Rake tasks to manage a Selenium Grid on a *single* machine.

   NOTE: To manage a Grid accross *multiple* machines use the 
         Capistrano recipes provided with Selenium Grid distribution
 
 
 Start the Hub and 20 Remote Controls
 ------------------------------------
 
    rake all:start
   
 Stop the Hub and 20 Remote Controls
 -----------------------------------
 
    rake all:stop
   
 Restart the Hub and 20 Remote Controls
 --------------------------------------

    rake all:restart

 Start the Hub with only 10 Remote Controls, ports 5000 to 5010
 --------------------------------------------------------------

    rake all:restart PORTS=5000-5010

  Stop them with

    rake all:stop PORTS=5000-5010
  
 Start 5 Remote Controls with the Hub, ports 6500 to 6505
 --------------------------------------------------------

   rake rc:start_all PORTS=6500-6505

 Start a single Remote Control on port 6666
-------------------------------------------

    rake rc:start PORT=6666

   
  EOS
end

desc "Restart all  services (Hub a Remote Controls"
task :'all:restart' do
  Rake::Task[:'all:stop'].invoke rescue nil
  Rake::Task[:'all:start'].invoke
end

desc "Launch all  services (Hub a Remote Controls"
task :'all:start' do
  ENV['BACKGROUND'] = "true"
  Rake::Task[:'hub:start'].invoke
  puts "Waiting for Hub to come up..."
  TCPSocket.wait_for_service :host => "localhost", :port => 4444
  Rake::Task[:'rc:start_all'].invoke
end

desc "Stop all  services (Hub a Remote Controls"
task :'all:stop' do
  Rake::Task[:'rc:stop_all'].invoke
  Rake::Task[:'hub:stop'].invoke rescue nil
end

desc "Launch Hub"
task :'hub:start' do
  classpath = Java::Classpath.new(File.dirname(__FILE__))
  classpath = classpath << "." << "lib/selenium-grid-hub-standalone-*.jar"
  puts classpath.inspect
  Java::VM.new.run "com.thoughtworks.selenium.grid.hub.HubServer",
                    :classpath => classpath.definition,
                    :background => ("true" == ENV['BACKGROUND']),
                    :log_file => File.native_path(File.dirname(__FILE__) + "/log/hub.log")
end

desc "Stop Hub"
task :'hub:stop' do
  sh "kill `lsof -t -i :4444`"
end

desc "Launch Remote Control"
task :'rc:start' do
  launch_rc(:port => (ENV['PORT'] || 5555)) 
end

desc "Stop Remote Control"
task :'rc:stop' do
  sh "kill `lsof -t -i :#{ENV['PORT'] || 5555}`"
end

desc "Launch Remote Control"
task :'rc:start_all' do
  ports = ENV['PORTS'] || "5000-5020"
  port_range = Range.new(*ports.split("-"))
  port_range.each do |port|
    ENV['BACKGROUND'] = "true"
    launch_rc(:port => port)
  end
end

desc"Stop Remote Controls. Usage rake rc:stop PORTS=5555-5560"
task :'rc:stop_all' do
  port_range = ENV['PORTS'] || "5000-5020"
  sh "kill `lsof -t -i :#{port_range}`"
end

desc "Launch a Xvnc server"
task :'xvnc:start' do
  sh "Xvnc :1 -alwaysshared -geometry 1280x1024 -depth 24 -desktop 'Selenium Grid' 2>&1 >#{File.join(File.dirname(__FILE__), "log", "X.log")} &"
end

def launch_rc(options)
    # Selenium Server must be first in classpath
    classpath = Java::Classpath.new(File.dirname(__FILE__))
    classpath =  classpath << "." << "lib/selenium-server-*.jar" << "lib/selenium-grid-remote-control-standalone-*.jar"

    Java::VM.new.run "com.thoughtworks.selenium.grid.remotecontrol.SelfRegisteringRemoteControlLauncher",
                     :classpath => classpath.definition,
                     :args => rc_args(options),
                     :background => ENV['BACKGROUND'],
                     :log_file => File.join(File.dirname(__FILE__), "log", "rc-#{options[:port]}.log")
                     
end

def rc_args(options)
  args = []
  args << "-host" << (options[:host] || ENV['HOST'] || "localhost")
  args << "-port" << options[:port]
  args << "-hubUrl" << (options[:hub_url] || ENV['HUB_URL'] || 'http://localhost:4444')
  args << "-env '#{options[:environment] || ENV['ENVIRONMENT'] || "*chrome"}'" 
  args << (options[:selenium_args] || ENV['SELENIUM_ARGS'] || "")
  args
end

### To be extracted (eventually) ###



class File

    def self.native_path(path)
    expanded_path = File.expand_path(path)
    expanded_path.gsub!('/', '\\') if PLATFORM['win32']
    expanded_path
  end
end

module Java

  class Classpath
    require 'pathname'

    def initialize(root_dir)
      @root = root_dir
      @locations = []
      self
    end

    def <<(paths)
      @locations = (@locations << Dir[@root + '/' + paths]).flatten
      self
    end

    def definition
      @locations.map {|path| File.native_path(path)}.join(self.separator)

    end

    def separator
     PLATFORM['win32'] ? ";" : ":"
    end

  end

  class VM

    def run(classname, options)
      command = [ "java" ]
      command << "-cp \"#{options[:classpath]}\""
      command << classname
      command << jvm_properties(options[:properties])
      command << options[:args].join(' ') if options[:args]
      command << ">\"#{options[:log_file]}\" 2>&1" if options[:log_file]

      if options[:background ]
        if PLATFORM['win32']
          command.unshift("start")
        else
          command << "&"
        end
      end

      sh command.join(' ')
    end

    def jvm_properties(property_hash)
      return "" unless property_hash
      property_hash.inject([]) {|memo, (name, value)| memo << "-D#{name}=#{value}" }.join(' ')
    end

  end

end
